<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BuildMojo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">docker-maven-plugin</a> &gt; <a href="index.source.html" class="el_package">com.spotify.docker</a> &gt; <span class="el_source">BuildMojo.java</span></div><h1>BuildMojo.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2014 Spotify AB.
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package com.spotify.docker;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.Joiner;
import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Ordering;
import com.google.common.collect.Sets;

import com.spotify.docker.client.AnsiProgressHandler;
import com.spotify.docker.client.DockerClient;
import com.spotify.docker.client.exceptions.DockerException;
import com.typesafe.config.Config;
import com.typesafe.config.ConfigException;
import com.typesafe.config.ConfigFactory;
import com.typesafe.config.ConfigValue;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.model.Resource;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.PluginParameterExpressionEvaluator;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;
import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;
import org.codehaus.plexus.util.DirectoryScanner;
import org.codehaus.plexus.util.FileUtils;
import org.eclipse.jgit.api.errors.GitAPIException;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.text.MessageFormat;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.jar.JarEntry;
import java.util.jar.JarOutputStream;

import static com.google.common.base.CharMatcher.WHITESPACE;
import static com.google.common.base.Strings.isNullOrEmpty;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Ordering.natural;
import static com.spotify.docker.Utils.parseImageName;
import static com.spotify.docker.Utils.pushImage;
import static com.spotify.docker.Utils.pushImageTag;
import static com.spotify.docker.Utils.saveImage;
import static com.spotify.docker.Utils.writeImageInfoFile;
import static com.typesafe.config.ConfigRenderOptions.concise;
import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.Collections.emptyList;

/**
 * Used to build docker images.
 */
@Mojo(name = &quot;build&quot;, threadSafe = true)
public class BuildMojo extends AbstractDockerMojo {

<span class="fc" id="L93">  private static final Lock LOCK = new ReentrantLock();</span>

  /**
   * The Unix separator character.
   */
  private static final char UNIX_SEPARATOR = '/';

  /**
   * The Windows separator character.
   */
  private static final char WINDOWS_SEPARATOR = '\\';

  /**
   * Json Object Mapper to encode arguments map 
   */
<span class="fc" id="L108">  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();</span>
  
  /**
   * Directory containing the Dockerfile. If the value is not set, the plugin will generate a
   * Dockerfile using the required baseImage value, plus the optional entryPoint, cmd and maintainer
   * values. If this value is set the plugin will use the Dockerfile in the specified folder.
   */
  @Parameter(property = &quot;dockerDirectory&quot;)
  private String dockerDirectory;

  /**
   * Flag to skip docker build, making build goal a no-op. This can be useful when docker:build
   * is bound to package goal, and you want to build a jar but not a container. Defaults to false.
   */
  @Parameter(property = &quot;skipDockerBuild&quot;, defaultValue = &quot;false&quot;)
  private boolean skipDockerBuild;

  /**
   * Flag to attempt to pull base images even if older images exists locally. Sends the equivalent
   * of `--pull=true` to Docker daemon when building the image.
   */
  @Parameter(property = &quot;pullOnBuild&quot;, defaultValue = &quot;false&quot;)
  private boolean pullOnBuild;

  /** Set to true to pass the `--no-cache` flag to the Docker daemon when building an image. */
  @Parameter(property = &quot;noCache&quot;, defaultValue = &quot;false&quot;)
  private boolean noCache;

  /** Set to false to pass the `--rm` flag to the Docker daemon when building an image. */
  @Parameter(property = &quot;rm&quot;, defaultValue = &quot;true&quot;)
  private boolean rm;

  /** File path to save image as a tar archive after it is built. */
  @Parameter(property = &quot;saveImageToTarArchive&quot;)
  private String saveImageToTarArchive;

  /** Flag to push image after it is built. Defaults to false. */
  @Parameter(property = &quot;pushImage&quot;, defaultValue = &quot;false&quot;)
  private boolean pushImage;

  /** Flag to push image using their tags after it is built. Defaults to false. */
  @Parameter(property = &quot;pushImageTag&quot;, defaultValue = &quot;false&quot;)
  private boolean pushImageTag;

  /** Flag to use force option while tagging. Defaults to false. */
  @Parameter(property = &quot;forceTags&quot;, defaultValue = &quot;false&quot;)
  private boolean forceTags;

  /** The maintainer of the image. Ignored if dockerDirectory is set. */
  @Parameter(property = &quot;dockerMaintainer&quot;)
  private String maintainer;

  /** The base image to use. Ignored if dockerDirectory is set. */
  @Parameter(property = &quot;dockerBaseImage&quot;)
  private String baseImage;

  /** The entry point of the image. Ignored if dockerDirectory is set. */
  @Parameter(property = &quot;dockerEntryPoint&quot;)
  private String entryPoint;

  /** The volumes for the image */
  @Parameter(property = &quot;dockerVolumes&quot;)
  private String[] volumes;

  /** The labels for the image */
  @Parameter(property = &quot;dockerLabels&quot;)
  private String[] labels;

  /** The cmd command for the image. Ignored if dockerDirectory is set. */
  @Parameter(property = &quot;dockerCmd&quot;)
  private String cmd;

  /** The workdir for the image. Ignored if dockerDirectory is set */
  @Parameter(property = &quot;workdir&quot;)
  private String workdir;

  /** The user for the image. Ignored if dockerDirectory is set */
  @Parameter(property = &quot;user&quot;)
  private String user;

  /**
   * The run commands for the image.
   */
  @Parameter(property = &quot;dockerRuns&quot;)
  private List&lt;String&gt; runs;

  private List&lt;String&gt; runList;

  /** Flag to squash all run commands into one layer. Defaults to false. */
  @Parameter(property = &quot;squashRunCommands&quot;, defaultValue = &quot;false&quot;)
  private boolean squashRunCommands;

  /** All resources will be copied to this directory before building the image. */
  @Parameter(property = &quot;project.build.directory&quot;)
  protected String buildDirectory;

  @Parameter(property = &quot;dockerBuildProfile&quot;)
  private String profile;

  /**
   * Path to JSON file to write when tagging images.
   * Default is ${project.build.testOutputDirectory}/image_info.json
   */
  @Parameter(property = &quot;tagInfoFile&quot;,
      defaultValue = &quot;${project.build.testOutputDirectory}/image_info.json&quot;)
  protected String tagInfoFile;

  /**
   * If specified as true, a tag will be generated consisting of the first 7 characters of the most
   * recent git commit ID, resulting in something like {@code image:df8e8e6}. If there are any
   * changes not yet committed, the string '.DIRTY' will be appended to the end. Note, if a tag is
   * explicitly specified in the {@code newName} parameter, this flag will be ignored.
   */
  @Parameter(property = &quot;useGitCommitId&quot;, defaultValue = &quot;false&quot;)
  private boolean useGitCommitId;

  /**
   * Resources to include in the build. Specify resources by using the standard resource elements as
   * defined in the &lt;a href=&quot;http://maven.apache.org/pom.html#Resources&quot;&gt;resources&lt;/a&gt; section in
   * the pom reference. If dockerDirectory is not set, the {@code targetPath} value is the location
   * in the container where the resource should be copied to. The value is relative to '{@code /}'
   * in the container, and defaults to '{@code .}'. If dockerDirectory is set, {@code targetPath}
   * is relative to the dockerDirectory, and defaults to '{@code .}'. In that case, the Dockerfile
   * can copy the resources into the container using the ADD instruction.
   */
  @Parameter(property = &quot;dockerResources&quot;)
  private List&lt;Resource&gt; resources;

  /** Built image will be given this name. */
  @Parameter(property = &quot;dockerImageName&quot;)
  private String imageName;

  /** Additional tags to tag the image with. */
  @SuppressWarnings(&quot;MismatchedQueryAndUpdateOfCollection&quot;)
  @Parameter(property = &quot;dockerImageTags&quot;)
  private List&lt;String&gt; imageTags;

  @Parameter(property = &quot;dockerDefaultBuildProfile&quot;)
  private String defaultProfile;

  @Parameter(property = &quot;dockerEnv&quot;)
  private Map&lt;String, String&gt; env;

  @Parameter(property = &quot;dockerExposes&quot;)
  private List&lt;String&gt; exposes;

  private Set&lt;String&gt; exposesSet;

  @Parameter(defaultValue = &quot;${project}&quot;)
  private MavenProject mavenProject;

  @Parameter(property = &quot;dockerBuildArgs&quot;)
  private Map&lt;String, String&gt; buildArgs;  
  
  /** HEALTHCHECK. It expects a element for 'options' and 'cmd' 
   * Added in docker 1.12 (https://docs.docker.com/engine/reference/builder/#/healthcheck). 
   */
  @Parameter(property = &quot;healthcheck&quot;)
  private Map&lt;String, String&gt; healthcheck;

  private PluginParameterExpressionEvaluator expressionEvaluator;

  public BuildMojo() {
<span class="fc" id="L271">    this(null);</span>
<span class="fc" id="L272">  }</span>

<span class="fc" id="L274">  public BuildMojo(final String defaultProfile) {</span>
<span class="fc" id="L275">    this.defaultProfile = defaultProfile;</span>
<span class="fc" id="L276">  }</span>

  public String getImageName() {
<span class="nc" id="L279">    return imageName;</span>
  }

  public boolean getPushImage() {
<span class="nc" id="L283">    return pushImage;</span>
  }

  public boolean getPushImageTag() {
<span class="nc" id="L287">    return pushImageTag;</span>
  }

  public boolean getForceTags() {
<span class="nc" id="L291">    return forceTags;</span>
  }
  
  private boolean weShouldSkipDockerBuild() {
<span class="fc bfc" id="L295" title="All 2 branches covered.">    if (skipDockerBuild) {</span>
<span class="fc" id="L296">      getLog().info(&quot;Property skipDockerBuild is set&quot;);</span>
<span class="fc" id="L297">      return true;</span>
    }

<span class="fc" id="L300">    final String packaging = session.getCurrentProject().getPackaging();</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">    if (&quot;pom&quot;.equalsIgnoreCase(packaging)) {</span>
<span class="nc" id="L302">      getLog().info(&quot;Project packaging is &quot; + packaging);</span>
<span class="nc" id="L303">      return true;</span>
    }

<span class="fc bfc" id="L306" title="All 2 branches covered.">    if (dockerDirectory != null) {</span>
<span class="fc" id="L307">      final Path path = Paths.get(dockerDirectory, &quot;Dockerfile&quot;);</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">      if (!path.toFile().exists()) {</span>
<span class="nc" id="L309">        getLog().info(&quot;No Dockerfile in dockerDirectory&quot;);</span>
<span class="nc" id="L310">        return true;</span>
      }
    }

<span class="fc" id="L314">    return false;</span>
  }

  public boolean isSkipDockerBuild() {
<span class="fc" id="L318">    return skipDockerBuild;</span>
  }

  @Override
  public void execute() throws MojoExecutionException {
    try {
<span class="fc" id="L324">      LOCK.lock();</span>
<span class="fc" id="L325">      super.execute();</span>
    } finally {
<span class="fc" id="L327">      LOCK.unlock();</span>
    }
<span class="fc" id="L329">  }</span>

  @Override
  protected void execute(final DockerClient docker)
      throws MojoExecutionException, GitAPIException, IOException, DockerException,
             InterruptedException {

<span class="fc bfc" id="L336" title="All 2 branches covered.">    if (weShouldSkipDockerBuild()) {</span>
<span class="fc" id="L337">      getLog().info(&quot;Skipping docker build&quot;);</span>
<span class="fc" id="L338">      return;</span>
    }

    // Put the list of exposed ports into a TreeSet which will remove duplicates and keep them
    // in a sorted order. This is useful when we merge with ports defined in the profile.
<span class="fc" id="L343">    exposesSet = Sets.newTreeSet(exposes);</span>
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">    if (runs != null) {</span>
<span class="fc" id="L345">      runList = Lists.newArrayList(runs);</span>
    }
<span class="fc" id="L347">    expressionEvaluator = new PluginParameterExpressionEvaluator(session, execution);</span>

<span class="fc" id="L349">    final Git git = new Git();</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">    final String commitId = git.isRepository() ? git.getCommitId() : null;</span>

<span class="pc bpc" id="L352" title="1 of 2 branches missed.">    if (commitId == null) {</span>
<span class="fc" id="L353">      final String errorMessage =</span>
          &quot;Not a git repository, cannot get commit ID. Make sure git repository is initialized.&quot;;
<span class="pc bpc" id="L355" title="2 of 6 branches missed.">      if (useGitCommitId || ((imageName != null) &amp;&amp; imageName.contains(&quot;${gitShortCommitId}&quot;))) {</span>
<span class="nc" id="L356">        throw new MojoExecutionException(errorMessage);</span>
      } else {
<span class="fc" id="L358">        getLog().debug(errorMessage);</span>
      }
<span class="fc" id="L360">    } else {</span>
      // Put the git commit id in the project properties. Image names may contain
      // ${gitShortCommitId} in which case we want to fill in the actual value using the
      // expression evaluator. We will do that once here for image names loaded from the pom,
      // and again in the loadProfile method when we load values from the profile.
<span class="nc" id="L365">      mavenProject.getProperties().put(&quot;gitShortCommitId&quot;, commitId);</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">      if (imageName != null) {</span>
<span class="nc" id="L367">        imageName = expand(imageName);</span>
      }
<span class="nc bnc" id="L369" title="All 2 branches missed.">      if (baseImage != null) {</span>
<span class="nc" id="L370">        baseImage = expand(baseImage);</span>
      }
    }

<span class="fc" id="L374">    loadProfile();</span>
<span class="fc" id="L375">    validateParameters();</span>

<span class="fc" id="L377">    final String[] repoTag = parseImageName(imageName);</span>
<span class="fc" id="L378">    final String repo = repoTag[0];</span>
<span class="fc" id="L379">    final String tag = repoTag[1];</span>

<span class="pc bpc" id="L381" title="1 of 2 branches missed.">    if (useGitCommitId) {</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">      if (tag != null) {</span>
<span class="nc" id="L383">        getLog().warn(&quot;Ignoring useGitCommitId flag because tag is explicitly set in image name &quot;);</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">      } else if (commitId == null) {</span>
<span class="nc" id="L385">        throw new MojoExecutionException(</span>
            &quot;Cannot tag with git commit ID because directory not a git repo&quot;);
      } else {
<span class="nc" id="L388">        imageName = repo + &quot;:&quot; + commitId;</span>
      }
    }
<span class="fc" id="L391">    mavenProject.getProperties().put(&quot;imageName&quot;, imageName);</span>

<span class="fc" id="L393">    final String destination = getDestination();</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">    if (dockerDirectory == null) {</span>
<span class="fc" id="L395">      final List&lt;String&gt; copiedPaths = copyResources(destination);</span>
<span class="fc" id="L396">      createDockerFile(destination, copiedPaths);</span>
<span class="fc" id="L397">    } else {</span>
<span class="fc" id="L398">      final Resource resource = new Resource();</span>
<span class="fc" id="L399">      resource.setDirectory(dockerDirectory);</span>
<span class="fc" id="L400">      resources.add(resource);</span>
<span class="fc" id="L401">      copyResources(destination);</span>
    }

<span class="fc" id="L404">    buildImage(docker, destination, buildParams());</span>
<span class="fc" id="L405">    tagImage(docker, forceTags);</span>

<span class="fc" id="L407">    final DockerBuildInformation buildInfo = new DockerBuildInformation(imageName, getLog());</span>

<span class="pc bpc" id="L409" title="1 of 2 branches missed.">    if (&quot;docker&quot;.equals(mavenProject.getPackaging())) {</span>
<span class="nc" id="L410">      final File imageArtifact = createImageArtifact(mavenProject.getArtifact(), buildInfo);</span>
<span class="nc" id="L411">      mavenProject.getArtifact().setFile(imageArtifact);</span>
    }

    // Push specific tags specified in pom rather than all images
<span class="fc bfc" id="L415" title="All 2 branches covered.">    if (pushImageTag) {</span>
<span class="fc" id="L416">      pushImageTag(docker, imageName, imageTags, getLog(), isSkipDockerPush());</span>
    }

<span class="fc bfc" id="L419" title="All 2 branches covered.">    if (pushImage) {</span>
<span class="fc" id="L420">      pushImage(docker, imageName, imageTags, getLog(), buildInfo, getRetryPushCount(),</span>
<span class="fc" id="L421">          getRetryPushTimeout(), isSkipDockerPush());</span>
    }

<span class="pc bpc" id="L424" title="1 of 2 branches missed.">    if (saveImageToTarArchive != null) {</span>
<span class="nc" id="L425">        saveImage(docker, imageName, Paths.get(saveImageToTarArchive), getLog());</span>
    }

    // Write image info file
<span class="fc" id="L429">    writeImageInfoFile(buildInfo, tagInfoFile);</span>
<span class="fc" id="L430">  }</span>

  private String getDestination() {
<span class="fc" id="L433">    return Paths.get(buildDirectory, &quot;docker&quot;).toString();</span>
  }

  private File createImageArtifact(final Artifact mainArtifact,
                                   final DockerBuildInformation buildInfo) throws IOException {
<span class="nc" id="L438">    final String fileName = MessageFormat.format(</span>
<span class="nc" id="L439">        &quot;{0}-{1}-docker.jar&quot;, mainArtifact.getArtifactId(), mainArtifact.getVersion());</span>

<span class="nc" id="L441">    final File f = Paths.get(buildDirectory, fileName).toFile();</span>
<span class="nc" id="L442">    try (JarOutputStream out = new JarOutputStream(new FileOutputStream(f))) {</span>
<span class="nc" id="L443">      final JarEntry entry = new JarEntry(</span>
<span class="nc" id="L444">          MessageFormat.format(&quot;META-INF/docker/{0}/{1}/image-info.json&quot;,</span>
<span class="nc" id="L445">                               mainArtifact.getGroupId(), mainArtifact.getArtifactId()));</span>
<span class="nc" id="L446">      out.putNextEntry(entry);</span>
<span class="nc" id="L447">      out.write(buildInfo.toJsonBytes());</span>
    }

<span class="nc" id="L450">    return f;</span>
  }

  private void loadProfile() throws MojoExecutionException {

<span class="fc" id="L455">    final Config config = ConfigFactory.load();</span>

<span class="fc" id="L457">    defaultProfile = get(defaultProfile, config, &quot;docker.build.defaultProfile&quot;);</span>

<span class="fc bfc" id="L459" title="All 2 branches covered.">    if (profile == null) {</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">      if (defaultProfile == null) {</span>
<span class="fc" id="L461">        getLog().debug(&quot;Not using any build profile&quot;);</span>
<span class="fc" id="L462">        return;</span>
      } else {
<span class="nc" id="L464">        getLog().info(&quot;Using default build profile: &quot; + defaultProfile);</span>
<span class="nc" id="L465">        profile = defaultProfile;</span>
      }
    } else {
<span class="fc" id="L468">      getLog().info(&quot;Using build profile: &quot; + profile);</span>
    }

    Config profiles;
    try {
<span class="fc" id="L473">      profiles = config.getConfig(&quot;docker.build.profiles&quot;);</span>
<span class="nc" id="L474">    } catch (ConfigException.Missing e) {</span>
<span class="nc" id="L475">      profiles = ConfigFactory.empty();</span>
<span class="fc" id="L476">    }</span>

    // Profile selection
    final Config profileConfig;
    try {
<span class="fc" id="L481">      profileConfig = profiles.getConfig(profile);</span>
<span class="nc" id="L482">    } catch (ConfigException.Missing e) {</span>
<span class="nc" id="L483">      getLog().error(&quot;Docker build profile not found: &quot; + profile);</span>
<span class="nc" id="L484">      getLog().error(&quot;Docker build profiles available:&quot;);</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">      for (final String name : natural().sortedCopy(profiles.root().keySet())) {</span>
<span class="nc" id="L486">        getLog().error(name);</span>
<span class="nc" id="L487">      }</span>
<span class="nc" id="L488">      throw new MojoExecutionException(&quot;Docker build profile not found: &quot; + profile);</span>
<span class="fc" id="L489">    }</span>

<span class="fc" id="L491">    getLog().info(&quot;Build profile: &quot; + profile);</span>
<span class="fc" id="L492">    getLog().info(profileConfig.root().render(concise().setJson(true).setFormatted(true)));</span>

    // Resources
<span class="fc" id="L495">    List&lt;? extends Config&gt; resourceConfigs = emptyList();</span>
    try {
<span class="fc" id="L497">      resourceConfigs = profileConfig.getConfigList(&quot;resources&quot;);</span>
<span class="nc" id="L498">    } catch (ConfigException.Missing ignore) {</span>
<span class="fc" id="L499">    }</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">    for (final Config resourceConfig : resourceConfigs) {</span>
<span class="fc" id="L501">      final Resource resource = new Resource();</span>
      try {
<span class="fc" id="L503">        resource.setDirectory(expand(resourceConfig.getString(&quot;directory&quot;)));</span>
<span class="nc" id="L504">      } catch (ConfigException.Missing e) {</span>
<span class="nc" id="L505">        throw new MojoExecutionException(&quot;Invalid resource config, missing directory.&quot;, e);</span>
<span class="fc" id="L506">      }</span>
      try {
<span class="fc" id="L508">        resource.setTargetPath(expand(resourceConfig.getString(&quot;targetPath&quot;)));</span>
<span class="nc" id="L509">      } catch (ConfigException.Missing ignore) {</span>
<span class="fc" id="L510">      }</span>
      try {
<span class="fc" id="L512">        final List&lt;String&gt; includes = resourceConfig.getStringList(&quot;includes&quot;);</span>
<span class="fc" id="L513">        final List&lt;String&gt; expanded = newArrayList();</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">        for (final String raw : includes) {</span>
<span class="fc" id="L515">          expanded.add(expand(raw));</span>
<span class="fc" id="L516">        }</span>
<span class="fc" id="L517">        resource.setIncludes(expanded);</span>
<span class="nc" id="L518">      } catch (ConfigException.Missing ignore) {</span>
<span class="fc" id="L519">      }</span>
<span class="fc" id="L520">      resources.add(resource);</span>
<span class="fc" id="L521">    }</span>

    // Environment variables
<span class="fc" id="L524">    Config envConfig = ConfigFactory.empty();</span>
    try {
<span class="fc" id="L526">      envConfig = profileConfig.getConfig(&quot;env&quot;);</span>
<span class="nc" id="L527">    } catch (ConfigException.Missing ignore) {</span>
<span class="fc" id="L528">    }</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">    if (env == null) {</span>
<span class="nc" id="L530">      env = Maps.newHashMap();</span>
    }
<span class="fc bfc" id="L532" title="All 2 branches covered.">    for (final Map.Entry&lt;String, ConfigValue&gt; entry : envConfig.root().entrySet()) {</span>
<span class="fc" id="L533">      final String key = expand(entry.getKey());</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">      if (!env.containsKey(key)) {</span>
<span class="fc" id="L535">        env.put(key, expand(entry.getValue().unwrapped().toString()));</span>
      }
<span class="fc" id="L537">    }</span>

    // Exposed ports
<span class="fc" id="L540">    List&lt;String&gt; exposesList = emptyList();</span>
    try {
<span class="fc" id="L542">      exposesList = profileConfig.getStringList(&quot;exposes&quot;);</span>
<span class="nc" id="L543">    } catch (ConfigException.Missing ignore) {</span>
<span class="fc" id="L544">    }</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">    for (final String raw : exposesList) {</span>
<span class="fc" id="L546">      exposesSet.add(expand(raw));</span>
<span class="fc" id="L547">    }</span>

    try {
<span class="nc" id="L550">      runList.addAll(profileConfig.getStringList(&quot;runs&quot;));</span>
<span class="fc" id="L551">    } catch (ConfigException.Missing ignore) {</span>
<span class="nc" id="L552">    }</span>

    // Simple properties
<span class="fc" id="L555">    imageName = get(imageName, profileConfig, &quot;imageName&quot;);</span>
<span class="fc" id="L556">    baseImage = get(baseImage, profileConfig, &quot;baseImage&quot;);</span>
<span class="fc" id="L557">    entryPoint = get(entryPoint, profileConfig, &quot;entryPoint&quot;);</span>
<span class="fc" id="L558">    cmd = get(cmd, profileConfig, &quot;cmd&quot;);</span>
<span class="fc" id="L559">    workdir = get(workdir, profileConfig, &quot;workdir&quot;);</span>
<span class="fc" id="L560">    user = get(user, profileConfig, &quot;user&quot;);</span>
<span class="fc" id="L561">  }</span>

  private String get(final String override, final Config config, final String path)
      throws MojoExecutionException {
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">    if (override != null) {</span>
<span class="nc" id="L566">      return override;</span>
    }
    try {
<span class="fc" id="L569">      return expand(config.getString(path));</span>
<span class="fc" id="L570">    } catch (ConfigException.Missing e) {</span>
<span class="fc" id="L571">      return null;</span>
    }
  }

  private String expand(final String raw) throws MojoExecutionException {
    final Object value;
    try {
<span class="fc" id="L578">      value = expressionEvaluator.evaluate(raw);</span>
<span class="nc" id="L579">    } catch (ExpressionEvaluationException e) {</span>
<span class="nc" id="L580">      throw new MojoExecutionException(&quot;Expression evaluation failed: &quot; + raw, e);</span>
<span class="fc" id="L581">    }</span>

<span class="fc bfc" id="L583" title="All 2 branches covered.">    if (value == null) {</span>
<span class="fc" id="L584">      throw new MojoExecutionException(&quot;Undefined expression: &quot; + raw);</span>
    }

<span class="fc" id="L587">    return value.toString();</span>
  }

  private void validateParameters() throws MojoExecutionException {
<span class="fc bfc" id="L591" title="All 2 branches covered.">    if (dockerDirectory == null) {</span>
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">      if (baseImage == null) {</span>
<span class="nc" id="L593">        throw new MojoExecutionException(&quot;Must specify baseImage if dockerDirectory is null&quot;);</span>
      }
    } else {
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">      if (baseImage != null) {</span>
<span class="nc" id="L597">        getLog().warn(&quot;Ignoring baseImage because dockerDirectory is set&quot;);</span>
      }
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">      if (maintainer != null) {</span>
<span class="nc" id="L600">        getLog().warn(&quot;Ignoring maintainer because dockerDirectory is set&quot;);</span>
      }
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">      if (entryPoint != null) {</span>
<span class="nc" id="L603">        getLog().warn(&quot;Ignoring entryPoint because dockerDirectory is set&quot;);</span>
      }
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">      if (cmd != null) {</span>
<span class="nc" id="L606">        getLog().warn(&quot;Ignoring cmd because dockerDirectory is set&quot;);</span>
      }
<span class="pc bpc" id="L608" title="2 of 4 branches missed.">      if (runList != null &amp;&amp; !runList.isEmpty()) {</span>
<span class="nc" id="L609">        getLog().warn(&quot;Ignoring run because dockerDirectory is set&quot;);</span>
      }
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">      if (workdir != null) {</span>
<span class="nc" id="L612">        getLog().warn(&quot;Ignoring workdir because dockerDirectory is set&quot;);</span>
      }
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">      if (user != null) {</span>
<span class="nc" id="L615">        getLog().warn(&quot;Ignoring user because dockerDirectory is set&quot;);</span>
      }
    }
<span class="fc" id="L618">  }</span>

  private void buildImage(final DockerClient docker, final String buildDir,
                          final DockerClient.BuildParam... buildParams)
      throws MojoExecutionException, DockerException, IOException, InterruptedException {
<span class="fc" id="L623">    getLog().info(&quot;Building image &quot; + imageName);</span>
<span class="fc" id="L624">    docker.build(Paths.get(buildDir), imageName, new AnsiProgressHandler(), buildParams);</span>
<span class="fc" id="L625">    getLog().info(&quot;Built &quot; + imageName);</span>
<span class="fc" id="L626">  }</span>

  private void tagImage(final DockerClient docker, boolean forceTags)
      throws DockerException, InterruptedException, MojoExecutionException {
<span class="fc" id="L630">    final String imageNameWithoutTag = parseImageName(imageName)[0];</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">    for (final String imageTag : imageTags) {</span>
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">      if (!isNullOrEmpty(imageTag)){</span>
<span class="fc" id="L633">        getLog().info(&quot;Tagging &quot; + imageName + &quot; with &quot; + imageTag);</span>
<span class="fc" id="L634">        docker.tag(imageName, imageNameWithoutTag + &quot;:&quot; + imageTag, forceTags);</span>
      }
<span class="fc" id="L636">    }</span>
<span class="fc" id="L637">  }</span>

  private void createDockerFile(final String directory, final List&lt;String&gt; filesToAdd)
      throws IOException {

<span class="fc" id="L642">    final List&lt;String&gt; commands = newArrayList();</span>
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">    if (baseImage != null) {</span>
<span class="fc" id="L644">      commands.add(&quot;FROM &quot; + baseImage);</span>
    }
<span class="fc bfc" id="L646" title="All 2 branches covered.">    if (maintainer != null) {</span>
<span class="fc" id="L647">      commands.add(&quot;MAINTAINER &quot; + maintainer);</span>
    }

<span class="pc bpc" id="L650" title="1 of 2 branches missed.">    if (env != null) {</span>
<span class="fc" id="L651">      final List&lt;String&gt; sortedKeys = Ordering.natural().sortedCopy(env.keySet());</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">      for (final String key : sortedKeys) {</span>
<span class="fc" id="L653">        final String value = env.get(key);</span>
<span class="fc" id="L654">        commands.add(String.format(&quot;ENV %s %s&quot;, key, value));</span>
<span class="fc" id="L655">      }</span>
    }

<span class="fc bfc" id="L658" title="All 2 branches covered.">    if (workdir != null) {</span>
<span class="fc" id="L659">      commands.add(&quot;WORKDIR &quot; + workdir);</span>
    }

<span class="fc bfc" id="L662" title="All 2 branches covered.">    for (final String file : filesToAdd) {</span>
      // The dollar sign in files has to be escaped because docker interprets it as variable
<span class="fc" id="L664">      commands.add(</span>
<span class="fc" id="L665">              String.format(&quot;ADD %s %s&quot;, file.replaceAll(&quot;\\$&quot;, &quot;\\\\\\$&quot;), normalizeDest(file)));</span>
<span class="fc" id="L666">    }</span>

<span class="pc bpc" id="L668" title="1 of 4 branches missed.">    if (runList != null &amp;&amp; !runList.isEmpty()) {</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">      if (squashRunCommands) {</span>
<span class="fc" id="L670">        commands.add(&quot;RUN &quot; + Joiner.on(&quot; &amp;&amp;\\\n\t&quot;).join(runList));</span>
      } else {
<span class="fc bfc" id="L672" title="All 2 branches covered.">        for (final String run : runList) {</span>
<span class="fc" id="L673">          commands.add(&quot;RUN &quot; + run);</span>
<span class="fc" id="L674">        }</span>
      }
    }

<span class="pc bpc" id="L678" title="1 of 4 branches missed.">    if (healthcheck != null &amp;&amp; healthcheck.containsKey(&quot;cmd&quot;)) {</span>
<span class="fc" id="L679">      final StringBuffer healthcheckBuffer = new StringBuffer(&quot;HEALTHCHECK &quot;);</span>
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">      if (healthcheck.containsKey(&quot;options&quot;)) {</span>
<span class="fc" id="L681">        healthcheckBuffer.append(healthcheck.get(&quot;options&quot;));</span>
<span class="fc" id="L682">        healthcheckBuffer.append(&quot; &quot;);</span>
      }
<span class="fc" id="L684">      healthcheckBuffer.append(&quot;CMD &quot;);</span>
<span class="fc" id="L685">      healthcheckBuffer.append(healthcheck.get(&quot;cmd&quot;));</span>
<span class="fc" id="L686">      commands.add(healthcheckBuffer.toString());</span>
    }

<span class="fc bfc" id="L689" title="All 2 branches covered.">    if (exposesSet.size() &gt; 0) {</span>
      // The values will be sorted with no duplicated since exposesSet is a TreeSet
<span class="fc" id="L691">      commands.add(&quot;EXPOSE &quot; + Joiner.on(&quot; &quot;).join(exposesSet));</span>
    }

<span class="fc bfc" id="L694" title="All 2 branches covered.">    if (user != null) {</span>
<span class="fc" id="L695">      commands.add(&quot;USER &quot; + user);</span>
    }

<span class="pc bpc" id="L698" title="1 of 2 branches missed.">    if (entryPoint != null) {</span>
<span class="fc" id="L699">      commands.add(&quot;ENTRYPOINT &quot; + entryPoint);</span>
    }
<span class="fc bfc" id="L701" title="All 2 branches covered.">    if (cmd != null) {</span>
      // TODO(dano): we actually need to check whether the base image has an entrypoint
<span class="pc bpc" id="L703" title="1 of 2 branches missed.">      if (entryPoint != null) {</span>
        // CMD needs to be a list of arguments if ENTRYPOINT is set.
<span class="pc bpc" id="L705" title="3 of 4 branches missed.">        if (cmd.startsWith(&quot;[&quot;) &amp;&amp; cmd.endsWith(&quot;]&quot;)) {</span>
          // cmd seems to be an argument list, so we're good
<span class="nc" id="L707">          commands.add(&quot;CMD &quot; + cmd);</span>
        } else {
          // cmd does not seem to be an argument list, so try to generate one.
<span class="fc" id="L710">          final List&lt;String&gt; args = ImmutableList.copyOf(</span>
<span class="fc" id="L711">              Splitter.on(WHITESPACE).omitEmptyStrings().split(cmd));</span>
<span class="fc" id="L712">          final StringBuilder cmdBuilder = new StringBuilder(&quot;[&quot;);</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">          for (final String arg : args) {</span>
<span class="fc" id="L714">            cmdBuilder.append('&quot;').append(arg).append('&quot;');</span>
<span class="fc" id="L715">          }</span>
<span class="fc" id="L716">          cmdBuilder.append(']');</span>
<span class="fc" id="L717">          final String cmdString = cmdBuilder.toString();</span>
<span class="fc" id="L718">          commands.add(&quot;CMD &quot; + cmdString);</span>
<span class="fc" id="L719">          getLog().warn(&quot;Entrypoint provided but cmd is not an explicit list. Attempting to &quot; +</span>
                        &quot;generate CMD string in the form of an argument list.&quot;);
<span class="fc" id="L721">          getLog().warn(&quot;CMD &quot; + cmdString);</span>
<span class="fc" id="L722">        }</span>
      } else {
        // no ENTRYPOINT set so use cmd verbatim
<span class="nc" id="L725">        commands.add(&quot;CMD &quot; + cmd);</span>
      }
    }

    // Add VOLUME's to dockerfile
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">    if (volumes != null) {</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">      for (final String volume : volumes) {</span>
<span class="fc" id="L732">        commands.add(&quot;VOLUME &quot; + volume);</span>
      }
    }

    // Add LABEL's to dockerfile
<span class="pc bpc" id="L737" title="1 of 2 branches missed.">    if (labels != null) {</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">      for (final String label : labels) {</span>
<span class="fc" id="L739">        commands.add(&quot;LABEL &quot; + label);</span>
      }
    }

<span class="fc" id="L743">    getLog().debug(&quot;Writing Dockerfile:&quot; + System.lineSeparator() +</span>
<span class="fc" id="L744">                   Joiner.on(System.lineSeparator()).join(commands));</span>

    // this will overwrite an existing file
<span class="fc" id="L747">    Files.createDirectories(Paths.get(directory));</span>
<span class="fc" id="L748">    Files.write(Paths.get(directory, &quot;Dockerfile&quot;), commands, UTF_8);</span>
<span class="fc" id="L749">  }</span>

  private String normalizeDest(final String filePath) {
    // if the path is a file (i.e. not a directory), remove the last part of the path so that we
    // end up with:
    //   ADD foo/bar.txt foo/
    // instead of
    //   ADD foo/bar.txt foo/bar.txt
    // This is to prevent issues when adding tar.gz or other archives where Docker will
    // automatically expand the archive into the &quot;dest&quot;, so
    //  ADD foo/x.tar.gz foo/x.tar.gz
    // results in x.tar.gz being expanded *under* the path foo/x.tar.gz/stuff...
<span class="fc" id="L761">    final File file = new File(filePath);</span>

    final String dest;
    // need to know the path relative to destination to test if it is a file or directory,
    // but only remove the last part of the path if there is a parent (i.e. don't remove a
    // parent path segment from &quot;file.txt&quot;)
<span class="fc bfc" id="L767" title="All 2 branches covered.">    if (new File(getDestination(), filePath).isFile()) {</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">      if (file.getParent() != null) {</span>
        // remove file part of path
<span class="fc" id="L770">        dest = separatorsToUnix(file.getParent()) + &quot;/&quot;;</span>
      } else {
        // working with a simple &quot;ADD file.txt&quot;
<span class="fc" id="L773">        dest = &quot;.&quot;;</span>
      }
    } else {
<span class="fc" id="L776">      dest = separatorsToUnix(file.getPath());</span>
    }

<span class="fc" id="L779">    return dest;</span>
  }

  @SuppressFBWarnings(&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;)
  private List&lt;String&gt; copyResources(String destination) throws IOException {

<span class="fc" id="L785">    final List&lt;String&gt; allCopiedPaths = newArrayList();</span>

<span class="fc bfc" id="L787" title="All 2 branches covered.">    for (final Resource resource : resources) {</span>
<span class="fc" id="L788">      final File source = new File(resource.getDirectory());</span>
<span class="fc" id="L789">      final List&lt;String&gt; includes = resource.getIncludes();</span>
<span class="fc" id="L790">      final List&lt;String&gt; excludes = resource.getExcludes();</span>
<span class="fc" id="L791">      final DirectoryScanner scanner = new DirectoryScanner();</span>
<span class="fc" id="L792">      scanner.setBasedir(source);</span>
      // must pass null if includes/excludes is empty to get default filters.
      // passing zero length array forces it to have no filters at all.
<span class="fc bfc" id="L795" title="All 2 branches covered.">      scanner.setIncludes(includes.isEmpty() ? null</span>
<span class="fc" id="L796">                                             : includes.toArray(new String[includes.size()]));</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">      scanner.setExcludes(excludes.isEmpty() ? null</span>
<span class="fc" id="L798">                                             : excludes.toArray(new String[excludes.size()]));</span>
<span class="fc" id="L799">      scanner.scan();</span>

<span class="fc" id="L801">      final String[] includedFiles = scanner.getIncludedFiles();</span>
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">      if (includedFiles.length == 0) {</span>
<span class="nc" id="L803">        getLog().info(&quot;No resources will be copied, no files match specified patterns&quot;);</span>
      }

<span class="fc" id="L806">      final List&lt;String&gt; copiedPaths = newArrayList();</span>

<span class="pc bpc" id="L808" title="1 of 4 branches missed.">      final boolean copyWholeDir = includes.isEmpty() &amp;&amp; excludes.isEmpty() &amp;&amp;</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">                             resource.getTargetPath() != null;</span>

      // file location relative to docker directory, used later to generate Dockerfile
<span class="fc bfc" id="L812" title="All 2 branches covered.">      final String targetPath = resource.getTargetPath() == null ? &quot;&quot; : resource.getTargetPath();</span>

<span class="fc bfc" id="L814" title="All 2 branches covered.">      if (copyWholeDir) {</span>
<span class="fc" id="L815">        final Path destPath = Paths.get(destination, targetPath);</span>
<span class="fc" id="L816">        getLog().info(String.format(&quot;Copying dir %s -&gt; %s&quot;, source, destPath));</span>

<span class="fc" id="L818">        Files.createDirectories(destPath);</span>
<span class="fc" id="L819">        FileUtils.copyDirectoryStructure(source, destPath.toFile());</span>
<span class="fc" id="L820">        copiedPaths.add(separatorsToUnix(targetPath));</span>
<span class="fc" id="L821">      } else {</span>
<span class="fc bfc" id="L822" title="All 2 branches covered.">        for (final String included : includedFiles) {</span>
<span class="fc" id="L823">          final Path sourcePath = Paths.get(resource.getDirectory()).resolve(included);</span>
<span class="fc" id="L824">          final Path destPath = Paths.get(destination, targetPath).resolve(included);</span>
<span class="fc" id="L825">          getLog().info(String.format(&quot;Copying %s -&gt; %s&quot;, sourcePath, destPath));</span>
          // ensure all directories exist because copy operation will fail if they don't
<span class="fc" id="L827">          Files.createDirectories(destPath.getParent());</span>
<span class="fc" id="L828">          Files.copy(sourcePath, destPath, StandardCopyOption.REPLACE_EXISTING,</span>
                     StandardCopyOption.COPY_ATTRIBUTES);

<span class="fc" id="L831">          copiedPaths.add(separatorsToUnix(Paths.get(targetPath).resolve(included).toString()));</span>
        }
      }

      // The list of included files returned from DirectoryScanner can be in a different order
      // each time. This causes the ADD statements in the generated Dockerfile to appear in a
      // different order. We want to avoid this so each run of the plugin always generates the same
      // Dockerfile, which also makes testing easier. Sort the list of paths for each resource
      // before adding it to the allCopiedPaths list. This way we follow the ordering of the
      // resources in the pom, while making sure all the paths of each resource are always in the
      // same order.
<span class="fc" id="L842">      Collections.sort(copiedPaths);</span>
<span class="fc" id="L843">      allCopiedPaths.addAll(copiedPaths);</span>
<span class="fc" id="L844">    }</span>

<span class="fc" id="L846">    return allCopiedPaths;</span>
  }

  /**
   * Converts all separators to the Unix separator of forward slash.
   *
   * @param path  the path to be changed, null ignored
   * @return the updated path
   */
  public static String separatorsToUnix(final String path) {
<span class="pc bpc" id="L856" title="2 of 4 branches missed.">    if (path == null || path.indexOf(WINDOWS_SEPARATOR) == -1) {</span>
<span class="fc" id="L857">      return path;</span>
    }
<span class="nc" id="L859">    return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);</span>
  }

  private DockerClient.BuildParam[] buildParams() 
    throws UnsupportedEncodingException, JsonProcessingException {
<span class="fc" id="L864">    final List&lt;DockerClient.BuildParam&gt; buildParams = Lists.newArrayList();</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">    if (pullOnBuild) {</span>
<span class="fc" id="L866">      buildParams.add(DockerClient.BuildParam.pullNewerImage());</span>
    }
<span class="fc bfc" id="L868" title="All 2 branches covered.">    if (noCache) {</span>
<span class="fc" id="L869">      buildParams.add(DockerClient.BuildParam.noCache());</span>
    }
<span class="fc bfc" id="L871" title="All 2 branches covered.">    if (!rm) {</span>
<span class="fc" id="L872">        buildParams.add(DockerClient.BuildParam.rm(false));</span>
      }
<span class="fc bfc" id="L874" title="All 2 branches covered.">    if (!buildArgs.isEmpty()) {</span>
<span class="fc" id="L875">      buildParams.add(DockerClient.BuildParam.create(&quot;buildargs&quot;, </span>
<span class="fc" id="L876">        URLEncoder.encode(OBJECT_MAPPER.writeValueAsString(buildArgs), &quot;UTF-8&quot;)));</span>
    }
<span class="fc" id="L878">    return buildParams.toArray(new DockerClient.BuildParam[buildParams.size()]);</span>
  }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>